_string_{
    R2Str(R:data)->string:={
        string:tmp;
        tmp.size=0;
        tmp.ad=new(64);
        R2T(data,tmp.ad);
        while(N(tmp.ad+tmp.size)->B!=0){tmp.size=tmp.size+1};
        tmp.size=tmp.size+1;
        return(tmp)
    }
}
Class:string{
    [Public]N:ad;[Public]N:size;
    _init_()->N:={
        ad=0;size=0
    }
    _destroy_()->N:={
        if(ad!=0){free(ad);ad=0};
        size=0;
    }
    _string_:={
        N:ad,N:size
    }
    [Public]_return_string(string:s)->N:={//prevent RAII destroys data
        _destroy_();
        ad=new(s.size);
        size=s.size;
        memcopy(s.ad,ad,size)
    }
    [Public]=(string:s)->string:={
        _destroy_();
        ad=new(s.size);
        
        size=s.size;
        memcopy(s.ad,ad,s.size);
        return(this)
    }
    [Public]const(N:str)->N:={
        _destroy_();
        N:i=0;
        while(N(str+i)->B!=0){i=i+1};
        size=i+1;
        ad=new(size);
        memcopy(str,ad,size);
    }
    [Public]+(string:s)->string:={
        string:tmp;
        if(this.size!=0){//msgbox(0,&"msg",&"Hello World!3",0);
            tmp.size=s.size+size-1;
            tmp.ad=new(tmp.size);
            memcopy(ad,tmp.ad,size);
            memcopy(s.ad,tmp.ad+size-1,s.size);
        }{
            tmp=s;
        };
        return(tmp)
    }
    [Public]*(N:times)->string:={
        string:tmp;
        N:i=0;
        while(i<times){
            tmp=tmp+this;
            i=i+1
        };
        return(tmp)
    }
    [Public]ToR()->R:={
        return(T2R(ad))
    }
    [Public]==(string:s)->Boolen:={
        return(CmpStr(ad,s.ad))
    }
    [Public]!=(string:s)->Boolen:={
        return(not CmpStr(ad,s.ad))
    }
}